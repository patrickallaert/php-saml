<?php
namespace OneLogin\Saml2;

use Exception;
use RobRichards\XMLSecLibs\XMLSecurityKey;

/**
 * Main class of OneLogin's PHP Toolkit
 */
class Auth
{
    /**
     * @var Settings
     */
    private $settings;

    /**
     * User attributes data.
     *
     * @var array
     */
    private $attributes = [];

    /**
     * User attributes data with FriendlyName index.
     *
     * @var array
     */
    private $attributesWithFriendlyName = [];

    /**
     * @var ?string
     */
    private $nameId;

    /**
     * @var ?string
     */
    private $nameIdFormat;

    /**
     * @var ?string
     */
    private $nameIdNameQualifier;

    /**
     * @var ?string
     */
    private $nameIdSPNameQualifier;

    /**
     * @var bool
     */
    private $authenticated = false;


    /**
     * SessionIndex. When the user is logged, this stored it
     * from the AuthnStatement of the SAML Response
     *
     * @var ?string
     */
    private $sessionIndex;

    /**
     * SessionNotOnOrAfter. When the user is logged, this stored it
     * from the AuthnStatement of the SAML Response
     *
     * @var int|null
     */
    private $sessionExpiration;

    /**
     * The ID of the last message processed
     *
     * @var ?string
     */
    private $lastMessageId;

    /**
     * The ID of the last assertion processed
     *
     * @var ?string
     */
    private $lastAssertionId;

    /**
     * The NotOnOrAfter value of the valid SubjectConfirmationData
     * node (if any) of the last assertion processed
     *
     * @var ?int
     */
    private $lastAssertionNotOnOrAfter;

    /**
     * If any error.
     *
     * @var string[]
     */
    private $errors = [];

    /**
     * Last error object.
     *
     * @var ?Exception
     */
    private $lastErrorException;

    /**
     * Last AuthNRequest ID or LogoutRequest ID generated by this Service Provider
     *
     * @var string
     */
    private $lastRequestID;

    /**
     * Initializes the SP SAML instance.
     */
    public function __construct(array $settings)
    {
        $this->settings = new Settings($settings);
    }

    public function getSettings(): Settings
    {
        return $this->settings;
    }

    /**
     * Set the strict mode active/disable
     */
    public function setStrict(bool $value): void
    {
        $this->settings->setStrict($value);
    }

    /**
     * Process the SAML Response sent by the IdP.
     *
     * @throws Error
     * @throws ValidationError
     */
    public function processResponse(?string $requestId = null): void
    {
        $this->errors = [];
        $this->lastErrorException = null;

        if (!isset($_POST['SAMLResponse'])) {
            $this->errors[] = 'invalid_binding';
            throw new Error(
                'SAML Response not found, Only supported HTTP_POST Binding',
                Error::SAML_RESPONSE_NOT_FOUND
            );
        }

        // AuthnResponse -- HTTP_POST Binding
        $response = new Response($this->settings, $_POST['SAMLResponse']);

        if ($response->isValid($requestId)) {
            $this->attributes = $response->getAttributes();
            $this->attributesWithFriendlyName = $response->getAttributesWithFriendlyName();
            $this->nameId = $response->getNameId();
            $this->nameIdFormat = $response->getNameIdFormat();
            $this->nameIdNameQualifier = $response->getNameIdNameQualifier();
            $this->nameIdSPNameQualifier = $response->getNameIdSPNameQualifier();
            $this->authenticated = true;
            $this->sessionIndex = $response->getSessionIndex();
            $this->sessionExpiration = $response->getSessionNotOnOrAfter();
            $this->lastMessageId = $response->getId();
            $this->lastAssertionId = $response->getAssertionId();
            $this->lastAssertionNotOnOrAfter = $response->getAssertionNotOnOrAfter();
        } else {
            $this->errors[] = 'invalid_response';
            $this->lastErrorException = $response->getErrorException();
        }
    }

    /**
     * Process the SAML Logout Response / Logout Request sent by the IdP.
     *
     * @param bool        $keepLocalSession             When false will destroy the local session, otherwise will keep it
     * @param string|null $requestId                    The ID of the LogoutRequest sent by this SP to the IdP
     * @param bool        $retrieveParametersFromServer True if we want to use parameters from $_SERVER to validate the signature
     * @param ?callable   $cbDeleteSession              Callback to be executed to delete session
     * @param bool        $stay                         True if we want to stay (returns the url string) False to redirect
     *
     * @return string|null
     *
     * @throws Error
     */
    public function processSLO(
        bool $keepLocalSession = false,
        ?string $requestId = null,
        bool $retrieveParametersFromServer = false,
        ?callable $cbDeleteSession = null,
        bool $stay = false
    ) {
        $this->errors = [];
        $this->lastErrorException = null;
        if (isset($_GET['SAMLResponse'])) {
            $logoutResponse = new LogoutResponse($this->settings, $_GET['SAMLResponse']);
            if (!$logoutResponse->isValid($requestId, $retrieveParametersFromServer)) {
                $this->errors[] = 'invalid_logout_response';
                $this->lastErrorException = $logoutResponse->getErrorException();
            } elseif ($logoutResponse->getStatus() !== Constants::STATUS_SUCCESS) {
                $this->errors[] = 'logout_not_success';
            } else {
                $this->lastMessageId = $logoutResponse->id;
                if (!$keepLocalSession) {
                    if ($cbDeleteSession === null) {
                        Utils::deleteLocalSession();
                    } else {
                        $cbDeleteSession();
                    }
                }
            }
        } elseif (isset($_GET['SAMLRequest'])) {
            $logoutRequest = new LogoutRequest($this->settings, $_GET['SAMLRequest']);
            if (!$logoutRequest->isValid($retrieveParametersFromServer)) {
                $this->errors[] = 'invalid_logout_request';
                $this->lastErrorException = $logoutRequest->getErrorException();
            } else {
                if (!$keepLocalSession) {
                    if ($cbDeleteSession === null) {
                        Utils::deleteLocalSession();
                    } else {
                        $cbDeleteSession();
                    }
                }
                $this->lastMessageId = $logoutRequest->id;
                $responseBuilder = new LogoutResponse($this->settings);
                $responseBuilder->build($logoutRequest->id);

                $parameters = ['SAMLResponse' => $responseBuilder->getResponse()];
                if (isset($_GET['RelayState'])) {
                    $parameters['RelayState'] = $_GET['RelayState'];
                }

                if ($this->settings->getSecurityWantLogoutResponseSigned()) {
                    $parameters['SigAlg'] = $this->settings->getSecuritySignatureAlgorithm();
                    $parameters['Signature'] = $this->buildResponseSignature($parameters['SAMLResponse'], $parameters['RelayState'] ?? null, $parameters['SigAlg']);
                }

                return $this->redirectTo($this->settings->getIdPSingleLogoutServiceUrl(), $parameters, $stay);
            }
        } else {
            $this->errors[] = 'invalid_binding';
            throw new Error(
                'SAML LogoutRequest/LogoutResponse not found. Only supported HTTP_REDIRECT Binding',
                Error::SAML_LOGOUTMESSAGE_NOT_FOUND
            );
        }
    }

    /**
     * Redirects the user to the url past by parameter
     * or to the url that we defined in our SSO Request.
     *
     * @param string $url        The target URL to redirect the user.
     * @param array  $parameters Extra parameters to be passed as part of the url
     * @param bool   $stay       True if we want to stay (returns the url string) False to redirect
     */
    public function redirectTo(string $url = '', array $parameters = [], bool $stay = false): string
    {
        if (empty($url) && isset($_REQUEST['RelayState'])) {
            $url = $_REQUEST['RelayState'];
        }

        return Utils::redirect($url, $parameters, $stay);
    }

    public function isAuthenticated(): bool
    {
        return $this->authenticated;
    }

    public function getAttributes(): array
    {
        return $this->attributes;
    }

    public function getAttributesWithFriendlyName(): array
    {
        return $this->attributesWithFriendlyName;
    }

    public function getNameId(): ?string
    {
        return $this->nameId;
    }

    public function getNameIdFormat(): ?string
    {
        return $this->nameIdFormat;
    }

    public function getNameIdNameQualifier(): ?string
    {
        return $this->nameIdNameQualifier;
    }

    public function getNameIdSPNameQualifier(): ?string
    {
        return $this->nameIdSPNameQualifier;
    }

    public function getSessionIndex(): ?string
    {
        return $this->sessionIndex;
    }

    public function getSessionExpiration(): ?int
    {
        return $this->sessionExpiration;
    }

    public function getErrors(): array
    {
        return $this->errors;
    }

    public function getLastErrorException(): ?Exception
    {
        return $this->lastErrorException;
    }

    public function getAttribute(string $name): ?array
    {
        return $this->attributes[$name] ?? null;
    }

    public function getAttributeWithFriendlyName(string $friendlyName): ?array
    {
        return $this->attributesWithFriendlyName[$friendlyName] ?? null;
    }

    /**
     * Initiates the SSO process.
     *
     * @param string|null $returnTo        The target URL the user should be returned to after login.
     * @param array       $parameters      Extra parameters to be added to the GET
     * @param bool        $forceAuthn      When true the AuthNRequest will set the ForceAuthn='true'
     * @param bool        $isPassive       When true the AuthNRequest will set the Ispassive='true'
     * @param bool        $stay            True if we want to stay (returns the url string) False to redirect
     * @param bool        $setNameIdPolicy When true the AuthNRequest will set a nameIdPolicy element
     *
     * @throws Error
     */
    public function login(
        ?string $returnTo = null,
        array $parameters = [],
        bool $forceAuthn = false,
        bool $isPassive = false,
        bool $stay = false,
        bool $setNameIdPolicy = true
    ): string {
        $authnRequest = new AuthnRequest($this->settings, $forceAuthn, $isPassive, $setNameIdPolicy);

        $this->lastRequestID = $authnRequest->getId();

        $parameters['SAMLRequest'] = $authnRequest->getRequest();
        $parameters['RelayState'] = !empty($returnTo) ? $returnTo : Utils::getSelfRoutedURLNoQuery();

        if ($this->settings->getSecurityAuthnRequestsSigned()) {
            $parameters['SigAlg'] = $this->settings->getSecuritySignatureAlgorithm();
            $parameters['Signature'] = $this->buildRequestSignature($parameters['SAMLRequest'], $parameters['RelayState'], $parameters['SigAlg']);
        }

        ;
        return $this->redirectTo($this->settings->getIdPSingleSignOnServiceUrl(), $parameters, $stay);
    }

    /**
     * Initiates the SLO process.
     *
     * @param string|null $returnTo            The target URL the user should be returned to after logout.
     * @param array       $parameters          Extra parameters to be added to the GET
     * @param string|null $nameId              The NameID that will be set in the LogoutRequest.
     * @param string|null $sessionIndex        The SessionIndex (taken from the SAML Response in the SSO process).
     * @param bool        $stay                True if we want to stay (returns the url string) False to redirect
     * @param string|null $nameIdFormat        The NameID Format will be set in the LogoutRequest.
     * @param string|null $nameIdNameQualifier The NameID NameQualifier will be set in the LogoutRequest.
     *
     * @throws Error
     */
    public function logout(
        ?string $returnTo = null,
        array $parameters = [],
        ?string $nameId = null,
        ?string $sessionIndex = null,
        bool $stay = false,
        ?string $nameIdFormat = null,
        ?string $nameIdNameQualifier = null,
        ?string $nameIdSPNameQualifier = null
    ): string {
        $sloUrl = $this->settings->getIdPSingleLogoutServiceUrl();
        if (empty($sloUrl)) {
            throw new Error(
                'The IdP does not support Single Log Out',
                Error::SAML_SINGLE_LOGOUT_NOT_SUPPORTED
            );
        }

        if (empty($nameId) && !empty($this->nameId)) {
            $nameId = $this->nameId;
        }
        if (empty($nameIdFormat) && !empty($this->nameIdFormat)) {
            $nameIdFormat = $this->nameIdFormat;
        }

        $logoutRequest = new LogoutRequest($this->settings, null, $nameId, $sessionIndex, $nameIdFormat, $nameIdNameQualifier, $nameIdSPNameQualifier);

        $this->lastRequestID = $logoutRequest->id;

        $parameters['SAMLRequest'] = $logoutRequest->getRequest();
        $parameters['RelayState'] = !empty($returnTo) ? $returnTo : Utils::getSelfRoutedURLNoQuery();

        if ($this->settings->getSecurityWantLogoutRequestSigned()) {
            $parameters['SigAlg'] = $this->settings->getSecuritySignatureAlgorithm();
            $parameters['Signature'] = $this->buildRequestSignature($parameters['SAMLRequest'], $parameters['RelayState'], $parameters['SigAlg']);
        }

        return $this->redirectTo($sloUrl, $parameters, $stay);
    }

    /**
     * Gets the ID of the last AuthNRequest or LogoutRequest generated by the Service Provider.
     */
    public function getLastRequestID(): string
    {
        return $this->lastRequestID;
    }

    /**
     * Generates the Signature for a SAML Request
     *
     * @throws Exception
     * @throws Error
     */
    public function buildRequestSignature(string $samlRequest, string $relayState, string $signAlgorithm = XMLSecurityKey::RSA_SHA256): string
    {
        return $this->buildMessageSignature($samlRequest, $relayState, $signAlgorithm, "SAMLRequest");
    }

    /**
     * Generates the Signature for a SAML Response
     *
     * @throws Exception
     * @throws Error
     */
    public function buildResponseSignature(string $samlResponse, string $relayState, string $signAlgorithm = XMLSecurityKey::RSA_SHA256): string
    {
        return $this->buildMessageSignature($samlResponse, $relayState, $signAlgorithm, "SAMLResponse");
    }

    /**
     * Generates the Signature for a SAML Message
     *
     * @throws Exception
     * @throws Error
     */
    private function buildMessageSignature(string $samlMessage, string $relayState, string $signAlgorithm, string $type): string
    {
        $key = $this->settings->getSPkey();
        if ($key === null) {
            throw new Error(
                $type === "SAMLRequest" ?
                    "Trying to sign the SAML Request but can't load the SP private key" :
                    "Trying to sign the SAML Response but can't load the SP private key",
                Error::PRIVATE_KEY_NOT_FOUND
            );
        }

        $objKey = new XMLSecurityKey($signAlgorithm, ['type' => 'private']);
        $objKey->loadKey($key);

        if ($this->settings->getSecurityLowercaseUrlEncoding()) {
            $msg = $type . '=' . rawurlencode($samlMessage);
            if (isset($relayState)) {
                $msg .= '&RelayState=' . rawurlencode($relayState);
            }
            $msg .= '&SigAlg=' . rawurlencode($signAlgorithm);
        } else {
            $msg = $type . '=' . urlencode($samlMessage);
            if (isset($relayState)) {
                $msg .= '&RelayState=' . urlencode($relayState);
            }
            $msg .= '&SigAlg=' . urlencode($signAlgorithm);
        }
        return base64_encode($objKey->signData($msg));
    }

    public function getLastMessageId(): ?string
    {
        return $this->lastMessageId;
    }

    public function getLastAssertionId(): ?string
    {
        return $this->lastAssertionId;
    }

    public function getLastAssertionNotOnOrAfter(): ?int
    {
        return $this->lastAssertionNotOnOrAfter;
    }
}
